/*=============================================================================
  Class name: Util

  Responsabilities: 
  -Provide several useful routines to manipulate bitboards and do operations
  with them.

  Date: September 01, 2007
  ============================================================================*/
#include "common.h"

/*===============================================================================
  Get the position of the most significat bit in BITVECTOR (The algorithm used
  is based on binary search, see LMSBP_algorithm.txt for a description)
  ==============================================================================*/
int
Util::MSB_position (bitboard bitvector)
{
   static u_int shift[] = { 32, 16, 8, 4, 2, 1 };
   static bitboard masks[] = { 0xFFFFFFFF00000000LL,
                               0x00000000FFFF0000LL,
                               0x000000000000FF00LL,
                               0x00000000000000F0LL,
                               0x000000000000000CLL,
                               0x0000000000000002LL };

   if (bitvector == 0) return -1;

   u_int position = 64;
   for (u_int i = 0; i < 6; ++i)
      if (masks[i] & bitvector)
         bitvector >>= shift[i];
      else
         position -= shift[i];

   return position-1;
}

/*===============================================================================
  Get the position of the least significat bit in BITVECTOR (The algorithm used
  is based on binary search, see LMSBP_algorithm.txt for a description)
  ==============================================================================*/
int
Util::LSB_position (bitboard bitvector)
{
   static u_int shift[] = { 32, 16, 8, 4, 2, 1 };
   static bitboard masks[] = { 0x00000000FFFFFFFFLL,
                               0x000000000000FFFFLL,
                               0x00000000000000FFLL,
                               0x000000000000000FLL,
                               0x0000000000000003LL,
                               0x0000000000000001LL };

   if (bitvector == 0) return -1;

   u_int position = 1;
   for (u_int i = 0; i < 6; ++i)
      if (!(masks[i] & bitvector))
      {
         bitvector >>= shift[i];
         position += shift[i];
      }

   return position-1;
}

/*============================================================================
  Complexity: O(n) where n is the number of turned-on bits

  Note: There are at least two faster methods to do this task:

  (a) Using a precomputed table of size 2^8 to count the number of bits in
  blocks of eight bits. The code required by this method is rather compact,
  but requires a prior initialization.

  (b) Using binary counters of size 1, 2, 4, ..., 2^64. The code used by this
  method is rather compact, but without an explanation it is completely 
  cryptic.
  ==========================================================================*/
u_int 
Util::count_set_bits (bitboard bitvector)
{
   u_int n_bits = 0;

   while (bitvector)
   {
      n_bits++;
      bitvector &= bitvector - 1;
   }
   return n_bits;
}
